# 3. Converting data into DGGS

The key functionality for any DGGS is the indexing and conversion of data into the grid - known as
**ingestion**. Once vector (point, polygon or line) or raster data has been ingested into a DGGS
implementation, data can be hierarchically aggregated into parent zones at lower resolutions.

## Raster data to DGGS
There are four main approaches for converting raster data into DGGS.

Performing **zonal statistics** with DGGS cells requires first creating cell geometries over the 
raster extent, after which classic zonal statistics can be applied. This approach is computationally expensive but 
enables conversion to any lower refinement level of DGGS using any desired zonal statistics method.

The most straightforward approach is **binning raster pixel centroids**. In this method, the coordinates of
raster pixel centroids are queried to get corresponding DGGS cells indexes. This avoids expensive
vector geometry generation, as described above, but requires that the DGGS refinement level is close to
the resolution of the ingested raster. Using a lower DGGS resolution leads to data loss due to sparser distribution of
cells centroids compared to raster pixels. Significantly finer DGGS resolution introduces unnecessary 
overhead during sampling process and loss in performance of the algorithm. 

**DGGS grid centroids sampling** is similar but computationally heavier approach, in this case the cell centroids
of precreated grid are binned to the raster. 

The most careful approach is **weighted overlay** (conservative regridding). Unlike the previously described methods, 
this preserves the total value of the mapped variable across the spatial domain. The value of each DGGS cell is computed
based on the proportion of area overlap between the source raster pixel and the DGGS cell, so pixels with larger overlaps
have bigger influence.


![Raster data to DGGS](../files/figures/conversion_raster_to_dggs.png)

## Vector data to DGGS

The ingestion of vector **points** (point binning) is the simplest, as all DGGS implementations have methods for converting
coordinates to cell indexes. The optimal refinement level can be determined using nearest neighbour or Voronoi polygon generation.
Alternatively, it can also be calculated by processing all points in a loop, where features are converted into DGGS indexes and
duplicates are counted. With each iteration the refinement level is increased by one until there are no duplicates or the
resolution value is at a defined maximum.

**Lines** quantization is less common, it can be performed by treating line vertices as points to apply above methods for determining
optimal resolution and then binning the zones containing those vertices.

Ingesting **polygon** vector data is more challenging, as it requires careful selection of DGGS refinement level to minimize data
loss due to undersampling. An appropriate refinement level can be determined automatically with the following pseudo algorithm: 
first, calculate the area of the smallest polygon in the input dataset; next, calculate the average zone area of a range
of DGGS refinement levels. If the ratio of polygon area to zone area is smaller than the desired treshold, then the corresponding
resolution is suitable for ingestion.

There are three main options for ingesting polygon data:

- **Creating DGGS zones inside polygons (polyfill)**

In this case the grid is created only inside polygons after which spatial join is used to assign polygon attributes to created grid zones.

- **DGGS grid centroids spatial join**

This is the basic strategy where spatial join is used to assign polygon attributes to pre-created grid zones. 

- **Weighted overlay**

This is the most conservative yet computationally demanding approach. It works much like the weighted overlay method
described above in raster conversion chapter.


![Vector data to DGGS](../files/figures/conversion_vector_to_dggs.png)

